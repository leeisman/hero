// Code generated by entc, DO NOT EDIT.

package user

import (
	"hero/database/ent/predicate"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
)

// ID filters vertices based on their identifier.
func ID(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// SocialUserID applies equality check predicate on the "social_user_id" field. It's identical to SocialUserIDEQ.
func SocialUserID(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialUserID), v))
	})
}

// SocialAvatarURL applies equality check predicate on the "social_avatar_url" field. It's identical to SocialAvatarURLEQ.
func SocialAvatarURL(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialEmail applies equality check predicate on the "social_email" field. It's identical to SocialEmailEQ.
func SocialEmail(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialEmail), v))
	})
}

// SocialName applies equality check predicate on the "social_name" field. It's identical to SocialNameEQ.
func SocialName(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialName), v))
	})
}

// SocialType applies equality check predicate on the "social_type" field. It's identical to SocialTypeEQ.
func SocialType(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialType), v))
	})
}

// SocialPayload applies equality check predicate on the "social_payload" field. It's identical to SocialPayloadEQ.
func SocialPayload(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialPayload), v))
	})
}

// HeroPlayed applies equality check predicate on the "hero_played" field. It's identical to HeroPlayedEQ.
func HeroPlayed(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeroPlayed), v))
	})
}

// HeroRepeat applies equality check predicate on the "hero_repeat" field. It's identical to HeroRepeatEQ.
func HeroRepeat(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeroRepeat), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// SocialUserIDEQ applies the EQ predicate on the "social_user_id" field.
func SocialUserIDEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDNEQ applies the NEQ predicate on the "social_user_id" field.
func SocialUserIDNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDIn applies the In predicate on the "social_user_id" field.
func SocialUserIDIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialUserID), v...))
	})
}

// SocialUserIDNotIn applies the NotIn predicate on the "social_user_id" field.
func SocialUserIDNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialUserID), v...))
	})
}

// SocialUserIDGT applies the GT predicate on the "social_user_id" field.
func SocialUserIDGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDGTE applies the GTE predicate on the "social_user_id" field.
func SocialUserIDGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDLT applies the LT predicate on the "social_user_id" field.
func SocialUserIDLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDLTE applies the LTE predicate on the "social_user_id" field.
func SocialUserIDLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDContains applies the Contains predicate on the "social_user_id" field.
func SocialUserIDContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDHasPrefix applies the HasPrefix predicate on the "social_user_id" field.
func SocialUserIDHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDHasSuffix applies the HasSuffix predicate on the "social_user_id" field.
func SocialUserIDHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDEqualFold applies the EqualFold predicate on the "social_user_id" field.
func SocialUserIDEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialUserID), v))
	})
}

// SocialUserIDContainsFold applies the ContainsFold predicate on the "social_user_id" field.
func SocialUserIDContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialUserID), v))
	})
}

// SocialAvatarURLEQ applies the EQ predicate on the "social_avatar_url" field.
func SocialAvatarURLEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLNEQ applies the NEQ predicate on the "social_avatar_url" field.
func SocialAvatarURLNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLIn applies the In predicate on the "social_avatar_url" field.
func SocialAvatarURLIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialAvatarURL), v...))
	})
}

// SocialAvatarURLNotIn applies the NotIn predicate on the "social_avatar_url" field.
func SocialAvatarURLNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialAvatarURL), v...))
	})
}

// SocialAvatarURLGT applies the GT predicate on the "social_avatar_url" field.
func SocialAvatarURLGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLGTE applies the GTE predicate on the "social_avatar_url" field.
func SocialAvatarURLGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLLT applies the LT predicate on the "social_avatar_url" field.
func SocialAvatarURLLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLLTE applies the LTE predicate on the "social_avatar_url" field.
func SocialAvatarURLLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLContains applies the Contains predicate on the "social_avatar_url" field.
func SocialAvatarURLContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLHasPrefix applies the HasPrefix predicate on the "social_avatar_url" field.
func SocialAvatarURLHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLHasSuffix applies the HasSuffix predicate on the "social_avatar_url" field.
func SocialAvatarURLHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLEqualFold applies the EqualFold predicate on the "social_avatar_url" field.
func SocialAvatarURLEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialAvatarURLContainsFold applies the ContainsFold predicate on the "social_avatar_url" field.
func SocialAvatarURLContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialAvatarURL), v))
	})
}

// SocialEmailEQ applies the EQ predicate on the "social_email" field.
func SocialEmailEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailNEQ applies the NEQ predicate on the "social_email" field.
func SocialEmailNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailIn applies the In predicate on the "social_email" field.
func SocialEmailIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialEmail), v...))
	})
}

// SocialEmailNotIn applies the NotIn predicate on the "social_email" field.
func SocialEmailNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialEmail), v...))
	})
}

// SocialEmailGT applies the GT predicate on the "social_email" field.
func SocialEmailGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailGTE applies the GTE predicate on the "social_email" field.
func SocialEmailGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailLT applies the LT predicate on the "social_email" field.
func SocialEmailLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailLTE applies the LTE predicate on the "social_email" field.
func SocialEmailLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailContains applies the Contains predicate on the "social_email" field.
func SocialEmailContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailHasPrefix applies the HasPrefix predicate on the "social_email" field.
func SocialEmailHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailHasSuffix applies the HasSuffix predicate on the "social_email" field.
func SocialEmailHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailEqualFold applies the EqualFold predicate on the "social_email" field.
func SocialEmailEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialEmail), v))
	})
}

// SocialEmailContainsFold applies the ContainsFold predicate on the "social_email" field.
func SocialEmailContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialEmail), v))
	})
}

// SocialNameEQ applies the EQ predicate on the "social_name" field.
func SocialNameEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialName), v))
	})
}

// SocialNameNEQ applies the NEQ predicate on the "social_name" field.
func SocialNameNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialName), v))
	})
}

// SocialNameIn applies the In predicate on the "social_name" field.
func SocialNameIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialName), v...))
	})
}

// SocialNameNotIn applies the NotIn predicate on the "social_name" field.
func SocialNameNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialName), v...))
	})
}

// SocialNameGT applies the GT predicate on the "social_name" field.
func SocialNameGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialName), v))
	})
}

// SocialNameGTE applies the GTE predicate on the "social_name" field.
func SocialNameGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialName), v))
	})
}

// SocialNameLT applies the LT predicate on the "social_name" field.
func SocialNameLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialName), v))
	})
}

// SocialNameLTE applies the LTE predicate on the "social_name" field.
func SocialNameLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialName), v))
	})
}

// SocialNameContains applies the Contains predicate on the "social_name" field.
func SocialNameContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialName), v))
	})
}

// SocialNameHasPrefix applies the HasPrefix predicate on the "social_name" field.
func SocialNameHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialName), v))
	})
}

// SocialNameHasSuffix applies the HasSuffix predicate on the "social_name" field.
func SocialNameHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialName), v))
	})
}

// SocialNameEqualFold applies the EqualFold predicate on the "social_name" field.
func SocialNameEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialName), v))
	})
}

// SocialNameContainsFold applies the ContainsFold predicate on the "social_name" field.
func SocialNameContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialName), v))
	})
}

// SocialTypeEQ applies the EQ predicate on the "social_type" field.
func SocialTypeEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialType), v))
	})
}

// SocialTypeNEQ applies the NEQ predicate on the "social_type" field.
func SocialTypeNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialType), v))
	})
}

// SocialTypeIn applies the In predicate on the "social_type" field.
func SocialTypeIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialType), v...))
	})
}

// SocialTypeNotIn applies the NotIn predicate on the "social_type" field.
func SocialTypeNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialType), v...))
	})
}

// SocialTypeGT applies the GT predicate on the "social_type" field.
func SocialTypeGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialType), v))
	})
}

// SocialTypeGTE applies the GTE predicate on the "social_type" field.
func SocialTypeGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialType), v))
	})
}

// SocialTypeLT applies the LT predicate on the "social_type" field.
func SocialTypeLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialType), v))
	})
}

// SocialTypeLTE applies the LTE predicate on the "social_type" field.
func SocialTypeLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialType), v))
	})
}

// SocialTypeContains applies the Contains predicate on the "social_type" field.
func SocialTypeContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialType), v))
	})
}

// SocialTypeHasPrefix applies the HasPrefix predicate on the "social_type" field.
func SocialTypeHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialType), v))
	})
}

// SocialTypeHasSuffix applies the HasSuffix predicate on the "social_type" field.
func SocialTypeHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialType), v))
	})
}

// SocialTypeEqualFold applies the EqualFold predicate on the "social_type" field.
func SocialTypeEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialType), v))
	})
}

// SocialTypeContainsFold applies the ContainsFold predicate on the "social_type" field.
func SocialTypeContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialType), v))
	})
}

// SocialPayloadEQ applies the EQ predicate on the "social_payload" field.
func SocialPayloadEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadNEQ applies the NEQ predicate on the "social_payload" field.
func SocialPayloadNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadIn applies the In predicate on the "social_payload" field.
func SocialPayloadIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSocialPayload), v...))
	})
}

// SocialPayloadNotIn applies the NotIn predicate on the "social_payload" field.
func SocialPayloadNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSocialPayload), v...))
	})
}

// SocialPayloadGT applies the GT predicate on the "social_payload" field.
func SocialPayloadGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadGTE applies the GTE predicate on the "social_payload" field.
func SocialPayloadGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadLT applies the LT predicate on the "social_payload" field.
func SocialPayloadLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadLTE applies the LTE predicate on the "social_payload" field.
func SocialPayloadLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadContains applies the Contains predicate on the "social_payload" field.
func SocialPayloadContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadHasPrefix applies the HasPrefix predicate on the "social_payload" field.
func SocialPayloadHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadHasSuffix applies the HasSuffix predicate on the "social_payload" field.
func SocialPayloadHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadEqualFold applies the EqualFold predicate on the "social_payload" field.
func SocialPayloadEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSocialPayload), v))
	})
}

// SocialPayloadContainsFold applies the ContainsFold predicate on the "social_payload" field.
func SocialPayloadContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSocialPayload), v))
	})
}

// HeroPlayedEQ applies the EQ predicate on the "hero_played" field.
func HeroPlayedEQ(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeroPlayed), v))
	})
}

// HeroPlayedNEQ applies the NEQ predicate on the "hero_played" field.
func HeroPlayedNEQ(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHeroPlayed), v))
	})
}

// HeroPlayedIn applies the In predicate on the "hero_played" field.
func HeroPlayedIn(vs ...uint) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHeroPlayed), v...))
	})
}

// HeroPlayedNotIn applies the NotIn predicate on the "hero_played" field.
func HeroPlayedNotIn(vs ...uint) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHeroPlayed), v...))
	})
}

// HeroPlayedGT applies the GT predicate on the "hero_played" field.
func HeroPlayedGT(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHeroPlayed), v))
	})
}

// HeroPlayedGTE applies the GTE predicate on the "hero_played" field.
func HeroPlayedGTE(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHeroPlayed), v))
	})
}

// HeroPlayedLT applies the LT predicate on the "hero_played" field.
func HeroPlayedLT(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHeroPlayed), v))
	})
}

// HeroPlayedLTE applies the LTE predicate on the "hero_played" field.
func HeroPlayedLTE(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHeroPlayed), v))
	})
}

// HeroRepeatEQ applies the EQ predicate on the "hero_repeat" field.
func HeroRepeatEQ(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeroRepeat), v))
	})
}

// HeroRepeatNEQ applies the NEQ predicate on the "hero_repeat" field.
func HeroRepeatNEQ(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHeroRepeat), v))
	})
}

// HeroRepeatIn applies the In predicate on the "hero_repeat" field.
func HeroRepeatIn(vs ...uint) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHeroRepeat), v...))
	})
}

// HeroRepeatNotIn applies the NotIn predicate on the "hero_repeat" field.
func HeroRepeatNotIn(vs ...uint) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHeroRepeat), v...))
	})
}

// HeroRepeatGT applies the GT predicate on the "hero_repeat" field.
func HeroRepeatGT(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHeroRepeat), v))
	})
}

// HeroRepeatGTE applies the GTE predicate on the "hero_repeat" field.
func HeroRepeatGTE(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHeroRepeat), v))
	})
}

// HeroRepeatLT applies the LT predicate on the "hero_repeat" field.
func HeroRepeatLT(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHeroRepeat), v))
	})
}

// HeroRepeatLTE applies the LTE predicate on the "hero_repeat" field.
func HeroRepeatLTE(v uint) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHeroRepeat), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIsNil applies the IsNil predicate on the "created_at" field.
func CreatedAtIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreatedAt)))
	})
}

// CreatedAtNotNil applies the NotNil predicate on the "created_at" field.
func CreatedAtNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreatedAt)))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIsNil applies the IsNil predicate on the "updated_at" field.
func UpdatedAtIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdatedAt)))
	})
}

// UpdatedAtNotNil applies the NotNil predicate on the "updated_at" field.
func UpdatedAtNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdatedAt)))
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		p(s.Not())
	})
}
